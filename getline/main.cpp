/* Реализуйте функцию getline, которая считывает поток ввода посимвольно, пока
 * не достигнет конца потока или не встретит символ переноса строки ('\n'), и
 * возвращает C-style строку с прочитанными символами.
 *
 * Обратите внимание, что так как размер ввода заранее неизвестен, то вам нужно
 * будет перевыделять память в процессе чтения, если в потоке ввода оказалось
 * больше символов, чем вы ожидали.
 *
 * Память, возвращенная из функции будет освобождена оператором delete[].
 * Символ переноса строки ('\n') добавлять в строку не нужно, но не забудьте,
 * что в конце C-style строки должен быть завершающий нулевой символ.
 *
 * Требования к реализации: при выполнении данного задания вы можете определять
 * любые вспомогательные функции, если они вам нужны. Определять функцию main
 * не нужно.
 */

#include <iostream>
using namespace std;


char *resize(const char *str, unsigned size, unsigned new_size)
{
    char * new_str = new char[new_size];
    for(int i = 0; i < size && i < new_size; ++i)
        new_str[i] = str[i];
    delete[] str;
 
    return new_str;
}

char *getline()
{
    char c = '\0'; //инициализация контейнера
	unsigned current_size = 10; // начальный размер - 10
	char * str = new char[current_size];
	unsigned i; //счётчик

	for (i = 0; std::cin.get(c) && c != '\n'; ++i) // ходим до конца ввода
    {
		str[i] = c; // пишем символ
		//если приближаемся к концу увеличиваем массив в 1,5 раза
        //(current_size - 2) потому что надо оставить место под \0 на случай если это последняя итерация
		if (i == current_size - 2) str = resize(str, current_size, current_size *= 1.5);
	} 
	str[i] = '\0'; // добавляем в конце
	return resize(str, current_size, i + 1); // подгоняем финальный размер (i + 1) в целях экономии
}

int main(int argc, char const *argv[])
{
    cout << getline() << endl;
    return 0;
}